/* 
data-time 2020-04-03 18:26:54


伞屉国是一个以太阳能为主要发电手段的国家，因此他们国家中有着非常多的太阳能基站，
链接着的基站会组合成一个发电集群。但是不幸的是伞屉国不时会遭遇滔天的洪水，
当洪水淹没基站时，基站只能停止发电，同时被迫断开与相邻基站的链接。
你作为伞屉国的洪水观察员，有着这样的任务：在洪水到来时，
计算出发电集群被洪水淹没后被拆分成了多少个集群。

由于远古的宇宙战争的原因，伞屉文明是一个二维世界里的文明，
所以你可以这样理解发电基站的位置与他们的链接关系：
给你一个一维数组a，长度为n，表示了n个基站的位置高度信息。
数组的第i个元素a[i]表示第i个基站的海拔高度是a[i],
而下标相邻的基站才相邻并且建立链接，
即x号基站与x-1号基站、x+1号基站相邻。
特别的，1号基站仅与2号相邻，而n号基站仅与n-1号基站相邻。
当一场海拔高度为y的洪水到来时，海拔高度小于等于y的基站都会被认为需要停止发电，
同时断开与相邻基站的链接。

https://www.nowcoder.com/test/question/done?tid=32308276&qid=810016#summary



/*
每次洪水来的时候会淹没掉一些发电机。 如果我们能得到哪些发电机沉下去了， 就可以枚举每一个发电机的编号来进行处理。
 而每个沉下去的发电机有三种情况。
1. 两侧的发电机都沉下去了， 集群数 - 1;
2. 只有一侧的发电机沉下去， 集群数不变;
3. 两侧的发电机都未沉下去， 集群数 + 1.

但是如果在线做的话， 显然会TLE.

如果洪水是逐渐上涨， 那么每个发电机只会被淹没掉一次， 沉下去的发电机不可能再浮起来。 则我们对洪水高度和发电机都排序， 每次不同的洪水高度， 看成是洪水上涨又新淹没了一堆发电机， 将其记录在答案数组中， 最后一并输出即可。 离线算法的典型运用。
注意边界条件。 我们可以假设0号和n+1号发电机一直在水下即可。

时间复杂度O(nlogn + mlogm)  刚好可以过这个题。
*/

/*
总结:还是合并区间内的问题，不过需要进一定的改进优化，使用dp的方式记录
重点在于每个水电站只能被淹没一次。
*/


#include<bits/stdc++.h>
using namespace std;
  
struct nums{
    int idx;
    int h;
  
    bool operator <(nums other){
        return h < other.h;
    }
};
  
const int maxn = 200006;
nums a[maxn], b[maxn];
int ans[maxn];
int sunk[maxn];
  
int n, m;
  
int main(){
    scanf("%d", &n);
  
    for(int i = 1; i <= n; i++){
        a[i].idx = i;
        scanf("%d", &a[i].h);
    }
  
    sort(a + 1, a + n + 1);
    scanf("%d", &m);
  
    for(int i = 1; i <= m; i++){
        b[i].idx = i;
        scanf("%d", &b[i].h);
    }
  
    sort(b + 1, b + m + 1);
  
    int last = 1, ret = 1;
  
    sunk[0] = sunk[n+1] = 1;
  
    for(int i = 1; i <= m; i++){
        //查找本次会被淹没的值
        while(last <= n && a[last].h <= b[i].h){
            //查找对应的被淹没的index
            int idx = a[last].idx;
  
            sunk[idx] = 1;
            int adj = sunk[idx - 1] + sunk[idx + 1];//计算两边是否被淹没
            if(adj == 0)ret++;//两边都没被淹没，中间淹没了，数量+1
            else if(adj == 2)ret--;//两边连同本身都被淹没了，数量-1
            last++;
        }
        //计算结果值
        ans[b[i].idx] = ret;
    }
  
    for(int i = 1; i <= m; i++){
        printf("%d\n", ans[i]);
    }
  
    return 0;
}